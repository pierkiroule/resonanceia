<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ÉCHO – API et Générateur de prompts</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <header class="hero">
    <div class="hero-content">
      <p class="eyebrow">Webapp frugale</p>
      <h1>ÉCHO – une seule API, zéro IA externe</h1>
      <p class="lede">Configurez votre filtre résonant et obtenez les blocs prêts à coller dans GPT Builder.</p>
    </div>
  </header>

  <main class="container">
    <section class="card">
      <h2>Paramètres du filtre</h2>
      <form id="filter-form" class="form-grid">
        <div>
          <h3>Intentions</h3>
          <div class="checkbox-group" data-name="intentions">
            <label><input type="checkbox" value="exprimer" checked /> exprimer</label>
            <label><input type="checkbox" value="clarifier" /> clarifier</label>
            <label><input type="checkbox" value="apaiser" /> apaiser</label>
            <label><input type="checkbox" value="prendre du recul" /> prendre du recul</label>
          </div>
        </div>

        <div>
          <h3>Publics</h3>
          <div class="checkbox-group" data-name="publics">
            <label><input type="checkbox" value="ado" /> ado</label>
            <label><input type="checkbox" value="adulte" checked /> adulte</label>
            <label><input type="checkbox" value="parent" /> parent</label>
            <label><input type="checkbox" value="couple" /> couple</label>
            <label><input type="checkbox" value="famille" /> famille</label>
          </div>
        </div>

        <div>
          <h3>Styles</h3>
          <div class="checkbox-group" data-name="styles">
            <label><input type="checkbox" value="symbolique" /> symbolique</label>
            <label><input type="checkbox" value="corporel" /> corporel</label>
            <label><input type="checkbox" value="poetique" checked /> poétique</label>
            <label><input type="checkbox" value="cognitif" /> cognitif</label>
          </div>
        </div>

        <div>
          <h3>Intensité</h3>
          <div class="radio-group" data-name="intensite">
            <label><input type="radio" name="intensite" value="legere" checked /> légère</label>
            <label><input type="radio" name="intensite" value="moderee" /> modérée</label>
            <label><input type="radio" name="intensite" value="haute" /> haute</label>
          </div>
        </div>

        <div class="full-row">
          <label for="filtre-nom" class="input-label">Nom du filtre (optionnel)</label>
          <input id="filtre-nom" type="text" placeholder="Filtre ÉCHO personnel" />
        </div>

        <div class="full-row">
          <button type="button" id="generate" class="primary">Mettre à jour les prompts</button>
        </div>
      </form>
    </section>

    <section class="card">
      <h2>Résumé</h2>
      <p id="resume" class="resume"></p>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Prompt Système</h2>
        <button class="ghost" data-copy="system-prompt">Copier</button>
      </div>
      <textarea id="system-prompt" readonly></textarea>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Prompt GPT Action</h2>
        <button class="ghost" data-copy="config-prompt">Copier</button>
      </div>
      <textarea id="config-prompt" readonly></textarea>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Bloc OpenAPI (JSON)</h2>
        <button class="ghost" data-copy="openapi-json">Copier</button>
      </div>
      <textarea id="openapi-json" readonly></textarea>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Tester /api/echo</h2>
        <button class="ghost" id="call-api">Envoyer</button>
      </div>
      <label for="test-message" class="input-label">Message utilisateur</label>
      <input id="test-message" type="text" placeholder="Ex : Je me sens pris entre deux choix importants" />
      <pre id="api-response" class="api-response" aria-live="polite"></pre>
    </section>
  </main>

  <footer class="footer">
    <p>Déployable sur Render – serveur Express + page statique.</p>
  </footer>

  <script>
    const intensityDescriptions = {
      legere: 'Résonance légère, suggestions délicates.',
      moderee: 'Résonance modérée, reformulations engagées sans insistance.',
      haute: 'Résonance haute, présence marquée mais respectueuse.'
    };

    const form = document.getElementById('filter-form');
    const resumeEl = document.getElementById('resume');
    const systemPromptEl = document.getElementById('system-prompt');
    const configPromptEl = document.getElementById('config-prompt');
    const openapiEl = document.getElementById('openapi-json');
    const testInput = document.getElementById('test-message');
    const apiResponse = document.getElementById('api-response');

    function getSelectedValues(groupName) {
      const group = form.querySelector(`[data-name="${groupName}"]`);
      const inputs = group ? group.querySelectorAll('input:checked') : [];
      return Array.from(inputs).map((input) => input.value);
    }

    function getIntensity() {
      const radio = form.querySelector('input[name="intensite"]:checked');
      return radio ? radio.value : 'legere';
    }

    function buildListText(values, fallback = '—') {
      if (!values.length) return fallback;
      if (values.length === 1) return values[0];
      const last = values[values.length - 1];
      return `${values.slice(0, -1).join(', ')} et ${last}`;
    }

    function buildSystemPrompt({ intentions, publics, styles, intensite }) {
      const intentionsText = buildListText(intentions, 'les intentions choisies');
      const publicsText = buildListText(publics, 'les publics visés');
      const stylesText = buildListText(styles, 'les styles sélectionnés');
      const intensityText = intensityDescriptions[intensite] || intensityDescriptions.legere;

      const lines = [
        '===== PROMPT SYSTÈME ÉCHO =====',
        'Tu fonctionnes dans l’Espace de l’Écho : une aide à la reformulation et à la résonance empathique.',
        'Aucune connexion à des modèles externes ; tu utilises uniquement ton raisonnement et l’API locale ÉCHO.',
        '',
        `Intentions principales : ${intentionsText}.`,
        `Publics privilégiés : ${publicsText}.`,
        `Style recommandé : ${stylesText}.`,
        `Intensité : ${intensityText}.`,
        '',
        'Principes relationnels :',
        '- Reformuler et résonner plutôt qu’expliquer.',
        '- Ne pas interpréter à la place de la personne.',
        '- Ne pas fournir de diagnostic ni de conseil médical.',
        '- Laisser l’utilisateur libre de ses interprétations.',
        '',
        'Action unique autorisée : « echo_exterieur » (POST /api/echo).',
        '- Utiliser uniquement quand la personne demande un écho extérieur ou une vérification de ses mots.',
        '- Ne jamais afficher le JSON brut, seulement intégrer le résultat dans la réponse.',
        '===== FIN PROMPT SYSTÈME ====='
      ];

      if (styles.includes('symbolique')) {
        lines.splice(-2, 0, 'Tu peux évoquer des images et constellations symboliques si cela sert la résonance.');
      }
      if (styles.includes('poetique')) {
        lines.splice(-2, 0, 'Tu peux t’autoriser un langage métaphorique et suggestif.');
      }
      if (styles.includes('corporel')) {
        lines.splice(-2, 0, 'Tu peux inviter à revenir aux sensations corporelles sans interprétation clinique.');
      }

      return lines.join('\n');
    }

    function buildConfigPrompt({ intentions, publics, styles, intensite, filtreNom, systemPrompt, apiBase }) {
      const publicsText = buildListText(publics, 'les publics visés');
      const stylesText = buildListText(styles, 'les styles sélectionnés');
      const filtre = filtreNom || 'Filtre ÉCHO';

      return [
        '===== PROMPT GPT ACTION =====',
        'Objectif : configurer un GPT résonant avec une seule Action HTTP locale.',
        `Nom du GPT : ${filtre}.`,
        `Description : accompagne ${publicsText} dans un style ${stylesText} et une intensité ${intensite}.`,
        '',
        '1) Dans « Instructions », coller le prompt système ci-dessous :',
        systemPrompt,
        '',
        '2) Créer une Action nommée "echo_exterieur" :',
        '- Méthode : POST',
        `- URL : ${apiBase}/api/echo`,
        '- En-têtes : Content-Type: application/json',
        '- Corps JSON : { "message": "texte de l’utilisateur" }',
        '',
        '3) Utilisation : quand l’utilisateur demande un écho extérieur, appeler l’Action puis intégrer pivot, noyau, périphérie, centralité, tags et métaphore dans ta réponse.',
        'Pas d’autres endpoints, pas de simulateur ni de fallback IA.',
        '===== FIN PROMPT GPT ACTION ====='
      ].join('\n');
    }

    function buildOpenApiJson(apiBase) {
      const schema = {
        openapi: '3.1.0',
        info: {
          title: 'API ÉCHO – Résonance locale',
          version: '1.0.0',
          description: 'Analyse statique locale : pivot, noyau, périphérie, cooccurrences.'
        },
        servers: [{ url: apiBase }],
        paths: {
          '/api/echo': {
            post: {
              operationId: 'echo_exterieur',
              summary: "Analyse un message et renvoie l'écho structuré.",
              requestBody: {
                required: true,
                content: {
                  'application/json': {
                    schema: {
                      type: 'object',
                      properties: {
                        message: { type: 'string', description: 'Texte utilisateur à analyser' }
                      },
                      required: ['message']
                    }
                  }
                }
              },
              responses: {
                200: {
                  description: 'Écho calculé',
                  content: {
                    'application/json': {
                      schema: {
                        type: 'object',
                        properties: {
                          pivot: { type: 'string', nullable: true },
                          noyau: { type: 'array', items: { type: 'string' } },
                          peripherie: { type: 'array', items: { type: 'string' } },
                          centralite: { type: 'number' },
                          cooccurrences: {
                            type: 'object',
                            additionalProperties: { type: 'integer' }
                          },
                          tags: { type: 'array', items: { type: 'string' } },
                          metaphore: { type: 'string' },
                          echo: { type: 'string' }
                        },
                        required: ['noyau', 'peripherie', 'centralite', 'cooccurrences', 'tags', 'metaphore', 'echo']
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };

      return JSON.stringify(schema, null, 2);
    }

    function updateOutputs() {
      const intentions = getSelectedValues('intentions');
      const publics = getSelectedValues('publics');
      const styles = getSelectedValues('styles');
      const intensite = getIntensity();
      const filtreNom = document.getElementById('filtre-nom').value.trim();
      const apiBase = window.location.origin;

      const systemPrompt = buildSystemPrompt({ intentions, publics, styles, intensite });
      const configPrompt = buildConfigPrompt({ intentions, publics, styles, intensite, filtreNom, systemPrompt, apiBase });
      const openapiJson = buildOpenApiJson(apiBase);

      systemPromptEl.value = systemPrompt;
      configPromptEl.value = configPrompt;
      openapiEl.value = openapiJson;

      const resumeParts = [
        intentions.length ? `Intentions : ${buildListText(intentions)}` : 'Intentions : —',
        publics.length ? `Publics : ${buildListText(publics)}` : 'Publics : —',
        styles.length ? `Styles : ${buildListText(styles)}` : 'Styles : —',
        `Intensité : ${intensite}`
      ];
      const namePart = filtreNom ? `Filtre nommé : ${filtreNom}.` : 'Filtre sans nom explicite.';
      resumeEl.textContent = `${resumeParts.join(' | ')}. ${namePart}`;
    }

    function attachCopyButtons() {
      document.querySelectorAll('[data-copy]').forEach((button) => {
        button.addEventListener('click', () => {
          const targetId = button.getAttribute('data-copy');
          const target = document.getElementById(targetId);
          if (target) {
            target.select();
            target.setSelectionRange(0, target.value.length);
            navigator.clipboard.writeText(target.value);
            button.textContent = 'Copié !';
            setTimeout(() => (button.textContent = 'Copier'), 1200);
          }
        });
      });
    }

    function attachApiTester() {
      document.getElementById('call-api').addEventListener('click', async () => {
        const payload = { message: testInput.value || '' };
        apiResponse.textContent = 'Envoi en cours...';
        try {
          const response = await fetch('/api/echo', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await response.json();
          apiResponse.textContent = JSON.stringify(data, null, 2);
        } catch (error) {
          apiResponse.textContent = 'Erreur lors de l’appel : ' + error.message;
        }
      });
    }

    document.getElementById('generate').addEventListener('click', updateOutputs);
    form.addEventListener('change', updateOutputs);

    attachCopyButtons();
    attachApiTester();
    updateOutputs();
  </script>
</body>
</html>
