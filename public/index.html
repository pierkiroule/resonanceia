<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ÉCHO – API et Générateur de prompts</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <header class="hero">
    <div class="hero-content">
      <p class="eyebrow">Webapp frugale</p>
      <h1>ÉCHO – une seule API, zéro IA externe</h1>
      <p class="lede">Configurez votre filtre résonant et obtenez les blocs prêts à coller dans GPT Builder.</p>
    </div>
  </header>

  <main class="container">
    <section class="card">
      <div class="card-header">
        <h2>Tutoriel minimal – URL unique à partager</h2>
        <p class="lede">Donnez simplement cette URL à GPT Builder : il pourra lire la page, récupérer le QCM et le code d’Action.</p>
      </div>
      <div class="form-grid">
        <div class="full-row">
          <label for="tutorial-url" class="input-label">URL à partager</label>
          <input id="tutorial-url" type="text" readonly />
          <button class="ghost" data-copy="tutorial-url">Copier l’URL</button>
        </div>
        <div class="full-row">
          <h3>Code d’Action prêt à coller</h3>
          <textarea id="action-snippet" readonly rows="8"></textarea>
          <button class="ghost" data-copy="action-snippet">Copier le code d’Action</button>
        </div>
        <div class="full-row">
          <h3>Questions QCM que GPT peut lire</h3>
          <ul>
            <li>Nom du GPT et description brève.</li>
            <li>Voix / registre : poétique, didactique ou pragmatique.</li>
            <li>Structure de sortie : texte libre, puces ou petit JSON.</li>
            <li>Éléments à inclure : silences, allusions mythologiques, corps, tags.</li>
            <li>Fonctionnalités à activer/désactiver : recherche web, images, code interpreter.</li>
            <li>URL d’action API (défaut : /api/echo de cette page).</li>
          </ul>
          <p class="lede">Le chat connecté à l’appli peut charger cette URL, lire ces questions et générer la trame sans autre saisie.</p>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>Paramètres du filtre</h2>
      <form id="filter-form" class="form-grid">
        <div>
          <h3>Intentions</h3>
          <div class="checkbox-group" data-name="intentions">
            <label><input type="checkbox" value="exprimer" checked /> exprimer</label>
            <label><input type="checkbox" value="clarifier" /> clarifier</label>
            <label><input type="checkbox" value="apaiser" /> apaiser</label>
            <label><input type="checkbox" value="prendre du recul" /> prendre du recul</label>
          </div>
        </div>

        <div>
          <h3>Publics</h3>
          <div class="checkbox-group" data-name="publics">
            <label><input type="checkbox" value="ado" /> ado</label>
            <label><input type="checkbox" value="adulte" checked /> adulte</label>
            <label><input type="checkbox" value="parent" /> parent</label>
            <label><input type="checkbox" value="couple" /> couple</label>
            <label><input type="checkbox" value="famille" /> famille</label>
          </div>
        </div>

        <div>
          <h3>Styles</h3>
          <div class="checkbox-group" data-name="styles">
            <label><input type="checkbox" value="symbolique" /> symbolique</label>
            <label><input type="checkbox" value="corporel" /> corporel</label>
            <label><input type="checkbox" value="poetique" checked /> poétique</label>
            <label><input type="checkbox" value="cognitif" /> cognitif</label>
          </div>
        </div>

        <div>
          <h3>Intensité</h3>
          <div class="radio-group" data-name="intensite">
            <label><input type="radio" name="intensite" value="legere" checked /> légère</label>
            <label><input type="radio" name="intensite" value="moderee" /> modérée</label>
            <label><input type="radio" name="intensite" value="haute" /> haute</label>
          </div>
        </div>

        <div class="full-row">
          <label for="filtre-nom" class="input-label">Nom du filtre (optionnel)</label>
          <input id="filtre-nom" type="text" placeholder="Filtre ÉCHO personnel" />
        </div>

        <div class="full-row">
          <button type="button" id="generate" class="primary">Mettre à jour les prompts</button>
        </div>
      </form>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Formulaire QCM – Trame GPT Builder</h2>
        <p class="lede">Générez une trame prête à coller dans GPT Builder à partir de quelques choix rapides.</p>
      </div>
      <form id="trame-form" class="form-grid">
        <div>
          <label for="gpt-name" class="input-label">Nom du GPT</label>
          <input id="gpt-name" type="text" placeholder="Ex : Médiateur ÉCHO" value="Préms Écho intérieur" />
        </div>
        <div>
          <label for="gpt-description" class="input-label">Description brève</label>
          <input id="gpt-description" type="text" placeholder="Rôle et public en 1 phrase" value="Médiation poétique reliant sensations intérieures et mythes." />
        </div>
        <div>
          <h3>Voix / registre</h3>
          <div class="radio-group" data-name="registre">
            <label><input type="radio" name="registre" value="poetique" checked /> Poétique & suggestive</label>
            <label><input type="radio" name="registre" value="didactique" /> Didactique & clair</label>
            <label><input type="radio" name="registre" value="pragmatique" /> Pragmatique & concis</label>
          </div>
        </div>
        <div>
          <h3>Structure de sortie</h3>
          <div class="radio-group" data-name="structure">
            <label><input type="radio" name="structure" value="texte" checked /> Texte libre</label>
            <label><input type="radio" name="structure" value="puces" /> Puces courtes</label>
            <label><input type="radio" name="structure" value="json" /> Petit JSON</label>
          </div>
        </div>
        <div>
          <h3>Éléments à inclure</h3>
          <div class="checkbox-group" data-name="elements">
            <label><input type="checkbox" value="silences" checked /> Silences textuels autorisés</label>
            <label><input type="checkbox" value="mythes" checked /> Allusions mythologiques limitées</label>
            <label><input type="checkbox" value="corps" /> Retour aux sensations corporelles</label>
            <label><input type="checkbox" value="tags" /> Mentionner tags ou mots-clés</label>
          </div>
        </div>
        <div>
          <h3>Fonctionnalités</h3>
          <div class="checkbox-group" data-name="features">
            <label><input type="checkbox" value="web" /> Recherche web</label>
            <label><input type="checkbox" value="images" /> Génération d’images</label>
            <label><input type="checkbox" value="code" /> Code interpreter</label>
          </div>
        </div>
        <div class="full-row">
          <label for="api-url" class="input-label">URL d’action API</label>
          <input id="api-url" type="text" placeholder="https://.../api/echo" />
        </div>
        <div class="full-row">
          <button type="button" id="generate-trame" class="primary">Générer la trame GPT</button>
        </div>
      </form>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Trame GPT prête à coller</h2>
        <button class="ghost" data-copy="gpt-trame">Copier</button>
      </div>
      <textarea id="gpt-trame" readonly></textarea>
    </section>

    <section class="card">
      <h2>Résumé</h2>
      <p id="resume" class="resume"></p>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Prompt Système</h2>
        <button class="ghost" data-copy="system-prompt">Copier</button>
      </div>
      <textarea id="system-prompt" readonly></textarea>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Prompt GPT Action</h2>
        <button class="ghost" data-copy="config-prompt">Copier</button>
      </div>
      <textarea id="config-prompt" readonly></textarea>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Bloc OpenAPI (JSON)</h2>
        <button class="ghost" data-copy="openapi-json">Copier</button>
      </div>
      <textarea id="openapi-json" readonly></textarea>
    </section>

    <section class="card">
      <div class="card-header">
        <h2>Tester /api/echo</h2>
        <button class="ghost" id="call-api">Envoyer</button>
      </div>
      <label for="test-message" class="input-label">Message utilisateur</label>
      <input id="test-message" type="text" placeholder="Ex : Je me sens pris entre deux choix importants" />
      <pre id="api-response" class="api-response" aria-live="polite"></pre>
    </section>
  </main>

  <footer class="footer">
    <p>Déployable sur Render – serveur Express + page statique.</p>
  </footer>

  <script>
    const intensityDescriptions = {
      legere: 'Résonance légère, suggestions délicates.',
      moderee: 'Résonance modérée, reformulations engagées sans insistance.',
      haute: 'Résonance haute, présence marquée mais respectueuse.'
    };

    const form = document.getElementById('filter-form');
    const resumeEl = document.getElementById('resume');
    const systemPromptEl = document.getElementById('system-prompt');
    const configPromptEl = document.getElementById('config-prompt');
    const openapiEl = document.getElementById('openapi-json');
    const testInput = document.getElementById('test-message');
    const apiResponse = document.getElementById('api-response');
    const trameForm = document.getElementById('trame-form');
    const gptTrameEl = document.getElementById('gpt-trame');

    function getSelectedValues(groupName) {
      const group = form.querySelector(`[data-name="${groupName}"]`);
      const inputs = group ? group.querySelectorAll('input:checked') : [];
      return Array.from(inputs).map((input) => input.value);
    }

    function getIntensity() {
      const radio = form.querySelector('input[name="intensite"]:checked');
      return radio ? radio.value : 'legere';
    }

    function buildListText(values, fallback = '—') {
      if (!values.length) return fallback;
      if (values.length === 1) return values[0];
      const last = values[values.length - 1];
      return `${values.slice(0, -1).join(', ')} et ${last}`;
    }

    function getRadioValue(formEl, name, fallback = '') {
      const radio = formEl.querySelector(`input[name="${name}"]:checked`);
      return radio ? radio.value : fallback;
    }

    function getCheckedValues(formEl, groupName) {
      const group = formEl.querySelector(`[data-name="${groupName}"]`);
      const inputs = group ? group.querySelectorAll('input:checked') : [];
      return Array.from(inputs).map((input) => input.value);
    }

    function buildSystemPrompt({ intentions, publics, styles, intensite }) {
      const intentionsText = buildListText(intentions, 'les intentions choisies');
      const publicsText = buildListText(publics, 'les publics visés');
      const stylesText = buildListText(styles, 'les styles sélectionnés');
      const intensityText = intensityDescriptions[intensite] || intensityDescriptions.legere;

      const lines = [
        '===== PROMPT SYSTÈME ÉCHO =====',
        'Tu fonctionnes dans l’Espace de l’Écho : une aide à la reformulation et à la résonance empathique.',
        'Aucune connexion à des modèles externes ; tu utilises uniquement ton raisonnement et l’API locale ÉCHO.',
        '',
        `Intentions principales : ${intentionsText}.`,
        `Publics privilégiés : ${publicsText}.`,
        `Style recommandé : ${stylesText}.`,
        `Intensité : ${intensityText}.`,
        '',
        'Principes relationnels :',
        '- Reformuler et résonner plutôt qu’expliquer.',
        '- Ne pas interpréter à la place de la personne.',
        '- Ne pas fournir de diagnostic ni de conseil médical.',
        '- Laisser l’utilisateur libre de ses interprétations.',
        '',
        'Action unique autorisée : « echo_exterieur » (POST /api/echo).',
        '- Utiliser uniquement quand la personne demande un écho extérieur ou une vérification de ses mots.',
        '- Ne jamais afficher le JSON brut, seulement intégrer le résultat dans la réponse.',
        '===== FIN PROMPT SYSTÈME ====='
      ];

      if (styles.includes('symbolique')) {
        lines.splice(-2, 0, 'Tu peux évoquer des images et constellations symboliques si cela sert la résonance.');
      }
      if (styles.includes('poetique')) {
        lines.splice(-2, 0, 'Tu peux t’autoriser un langage métaphorique et suggestif.');
      }
      if (styles.includes('corporel')) {
        lines.splice(-2, 0, 'Tu peux inviter à revenir aux sensations corporelles sans interprétation clinique.');
      }

      return lines.join('\n');
    }

    function buildConfigPrompt({ intentions, publics, styles, intensite, filtreNom, systemPrompt, apiBase }) {
      const publicsText = buildListText(publics, 'les publics visés');
      const stylesText = buildListText(styles, 'les styles sélectionnés');
      const filtre = filtreNom || 'Filtre ÉCHO';

      return [
        '===== PROMPT GPT ACTION =====',
        'Objectif : configurer un GPT résonant avec une seule Action HTTP locale.',
        `Nom du GPT : ${filtre}.`,
        `Description : accompagne ${publicsText} dans un style ${stylesText} et une intensité ${intensite}.`,
        '',
        '1) Dans « Instructions », coller le prompt système ci-dessous :',
        systemPrompt,
        '',
        '2) Créer une Action nommée "echo_exterieur" :',
        '- Méthode : POST',
        `- URL : ${apiBase}/api/echo`,
        '- En-têtes : Content-Type: application/json',
        '- Corps JSON : { "message": "texte de l’utilisateur" }',
        '',
        '3) Utilisation : quand l’utilisateur demande un écho extérieur, appeler l’Action puis intégrer pivot, noyau, périphérie, centralité, tags et métaphore dans ta réponse.',
        'Pas d’autres endpoints, pas de simulateur ni de fallback IA.',
        '===== FIN PROMPT GPT ACTION ====='
      ].join('\n');
    }

    function buildOpenApiJson(apiBase) {
      const schema = {
        openapi: '3.1.0',
        info: {
          title: 'API ÉCHO – Résonance locale',
          version: '1.0.0',
          description: 'Analyse statique locale : pivot, noyau, périphérie, cooccurrences.'
        },
        servers: [{ url: apiBase }],
        paths: {
          '/api/echo': {
            post: {
              operationId: 'echo_exterieur',
              summary: "Analyse un message et renvoie l'écho structuré.",
              requestBody: {
                required: true,
                content: {
                  'application/json': {
                    schema: {
                      type: 'object',
                      properties: {
                        message: { type: 'string', description: 'Texte utilisateur à analyser' }
                      },
                      required: ['message']
                    }
                  }
                }
              },
              responses: {
                200: {
                  description: 'Écho calculé',
                  content: {
                    'application/json': {
                      schema: {
                        type: 'object',
                        properties: {
                          pivot: { type: 'string', nullable: true },
                          noyau: { type: 'array', items: { type: 'string' } },
                          peripherie: { type: 'array', items: { type: 'string' } },
                          centralite: { type: 'number' },
                          cooccurrences: {
                            type: 'object',
                            additionalProperties: { type: 'integer' }
                          },
                          tags: { type: 'array', items: { type: 'string' } },
                          metaphore: { type: 'string' },
                          echo: { type: 'string' }
                        },
                        required: ['noyau', 'peripherie', 'centralite', 'cooccurrences', 'tags', 'metaphore', 'echo']
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };

      return JSON.stringify(schema, null, 2);
    }

    function buildTrameGpt({ name, description, registre, structure, elements, features, apiUrl }) {
      const outputFormat = {
        texte: 'Sortie en texte libre, phrases courtes.',
        puces: 'Sortie sous forme de puces concises.',
        json: 'Sortie JSON minimal : { "echo": "...", "tags": [ ... ] }'
      }[structure] || 'Sortie en texte libre.';

      const styleLines = [];
      if (registre === 'poetique') styleLines.push('Voix poétique, sensorielle, suggestive.');
      if (registre === 'didactique') styleLines.push('Voix claire, structurée, pédagogique.');
      if (registre === 'pragmatique') styleLines.push('Voix pragmatique, directe, orientée action.');

      if (elements.includes('silences')) styleLines.push('Peut insérer des silences textuels (ligne vide ou …) pour laisser respirer.');
      if (elements.includes('mythes')) styleLines.push('Allusions mythologiques discrètes (1–2 maximum) en métaphore, sans interprétation.');
      if (elements.includes('corps')) styleLines.push('Invite à revenir aux sensations corporelles sans analyse clinique.');
      if (elements.includes('tags')) styleLines.push('Peut proposer quelques tags/mots-clés en fin de réponse.');

      const featureLines = ['Activer uniquement les fonctionnalités nécessaires :'];
      ['web', 'images', 'code'].forEach((feature) => {
        const labelMap = { web: 'Recherche web', images: 'Génération d’images', code: 'Code interpreter' };
        const label = labelMap[feature];
        featureLines.push(`${features.includes(feature) ? '✔︎' : '✘'} ${label}`);
      });

      return [
        `Nom : ${name || 'GPT personnalisé'}`,
        `Description : ${description || 'Décris en 1 phrase le rôle et le public visé.'}`,
        '',
        'Instructions :',
        '- Rôle : médiation / accompagnement en résonance.',
        `- Style : ${styleLines.join(' ') || 'choisir un registre.'}`,
        `- Format de sortie : ${outputFormat}`,
        '- À éviter : interprétations médicales/juridiques, diagnostics, divinations.',
        '- Quand se taire : accepter les silences, ne pas forcer la réponse.',
        '',
        'Bloc Appel API (Action) :',
        `- Méthode POST ${apiUrl || window.location.origin + '/api/echo'}`,
        '- Headers : Content-Type: application/json',
        '- Payload : { "message": "texte utilisateur" }',
        '- Afficher uniquement le champ poétique/echo + mention de source.',
        '- OpenAPI : /openapi.json',
        '',
        'Actions :',
        '- Action unique « echo_exterieur » : appeler si l’utilisateur demande un écho extérieur ou une vérification.',
        '- Ne pas inventer de réponse JSON si l’API échoue ; signaler simplement l’impossibilité provisoire.',
        '',
        'Amorces possibles :',
        '- « Je me sens perdu entre deux mondes. »',
        '- « Fais résonner mon silence avec les mythes anciens. »',
        '- « Parle-moi d’une métamorphose intérieure. »',
        '',
        featureLines.join('\n'),
        '',
        'Style de sortie : paragraphes courts, 1–2 références symboliques maximum, conclure par la mention « résonance issue de l’API ÉCHO ». '
      ].join('\n');
    }

    function hydrateTutorial({ apiBase }) {
      const tutorialUrlInput = document.getElementById('tutorial-url');
      const actionSnippet = document.getElementById('action-snippet');

      if (tutorialUrlInput) {
        tutorialUrlInput.value = window.location.href;
      }

      if (actionSnippet) {
        actionSnippet.value = [
          'Nom de l’Action : echo_exterieur',
          'Méthode : POST',
          `URL : ${apiBase}/api/echo`,
          'Headers : Content-Type: application/json',
          'Corps : { "message": "texte utilisateur" }',
          'Affichage : ne montrer que le champ poétique/echo + mention « résonance issue de l’API ÉCHO ».',
          'OpenAPI : disponible sur /openapi.json'
        ].join('\n');
      }
    }

    function updateOutputs() {
      const intentions = getSelectedValues('intentions');
      const publics = getSelectedValues('publics');
      const styles = getSelectedValues('styles');
      const intensite = getIntensity();
      const filtreNom = document.getElementById('filtre-nom').value.trim();
      const apiBase = window.location.origin;

      const systemPrompt = buildSystemPrompt({ intentions, publics, styles, intensite });
      const configPrompt = buildConfigPrompt({ intentions, publics, styles, intensite, filtreNom, systemPrompt, apiBase });
      const openapiJson = buildOpenApiJson(apiBase);

      systemPromptEl.value = systemPrompt;
      configPromptEl.value = configPrompt;
      openapiEl.value = openapiJson;

      const resumeParts = [
        intentions.length ? `Intentions : ${buildListText(intentions)}` : 'Intentions : —',
        publics.length ? `Publics : ${buildListText(publics)}` : 'Publics : —',
        styles.length ? `Styles : ${buildListText(styles)}` : 'Styles : —',
        `Intensité : ${intensite}`
      ];
      const namePart = filtreNom ? `Filtre nommé : ${filtreNom}.` : 'Filtre sans nom explicite.';
      resumeEl.textContent = `${resumeParts.join(' | ')}. ${namePart}`;

      hydrateTutorial({ apiBase });
    }

    function updateTrame() {
      const name = document.getElementById('gpt-name').value.trim();
      const description = document.getElementById('gpt-description').value.trim();
      const apiUrlInput = document.getElementById('api-url');
      const registre = getRadioValue(trameForm, 'registre', 'poetique');
      const structure = getRadioValue(trameForm, 'structure', 'texte');
      const elements = getCheckedValues(trameForm, 'elements');
      const features = getCheckedValues(trameForm, 'features');
      if (!apiUrlInput.value) {
        apiUrlInput.value = `${window.location.origin}/api/echo`;
      }
      const apiUrl = apiUrlInput.value.trim();

      gptTrameEl.value = buildTrameGpt({ name, description, registre, structure, elements, features, apiUrl });
    }

    function attachCopyButtons() {
      document.querySelectorAll('[data-copy]').forEach((button) => {
        button.addEventListener('click', () => {
          const targetId = button.getAttribute('data-copy');
          const target = document.getElementById(targetId);
          if (target) {
            target.select();
            target.setSelectionRange(0, target.value.length);
            navigator.clipboard.writeText(target.value);
            button.textContent = 'Copié !';
            setTimeout(() => (button.textContent = 'Copier'), 1200);
          }
        });
      });
    }

    function attachApiTester() {
      document.getElementById('call-api').addEventListener('click', async () => {
        const payload = { message: testInput.value || '' };
        apiResponse.textContent = 'Envoi en cours...';
        try {
          const response = await fetch('/api/echo', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await response.json();
          apiResponse.textContent = JSON.stringify(data, null, 2);
        } catch (error) {
          apiResponse.textContent = 'Erreur lors de l’appel : ' + error.message;
        }
      });
    }

    document.getElementById('generate').addEventListener('click', updateOutputs);
    form.addEventListener('change', updateOutputs);
    document.getElementById('generate-trame').addEventListener('click', updateTrame);
    trameForm.addEventListener('change', updateTrame);

    attachCopyButtons();
    attachApiTester();
    updateOutputs();
    updateTrame();
  </script>
</body>
</html>
